[{"/Users/drkrueger/Work/foodfrenzy/solana/mekamounts/mekamountpfp/web/src/index.js":"1","/Users/drkrueger/Work/foodfrenzy/solana/mekamounts/mekamountpfp/web/src/App.js":"2"},{"size":219,"mtime":1642696149993,"results":"3","hashOfConfig":"4"},{"size":11263,"mtime":1642744568441,"results":"5","hashOfConfig":"4"},{"filePath":"6","messages":"7","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"8"},"ccxvra",{"filePath":"9","messages":"10","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"11"},"/Users/drkrueger/Work/foodfrenzy/solana/mekamounts/mekamountpfp/web/src/index.js",[],["12","13"],"/Users/drkrueger/Work/foodfrenzy/solana/mekamounts/mekamountpfp/web/src/App.js",["14","15","16","17","18","19","20"],"import React, { useEffect, useState } from 'react';\n// import Mekamount, { runScript } from './createMekamount.js';\nimport querystring from 'query-string';\nimport twitterLogo from './assets/twitter-logo.svg';\nimport mekaHolder from './assets/meka.png';\nimport pfpHolder from './assets/pfp.png';\nimport download from 'downloadjs';\nimport './App.css';\n\n// Constants\nconst TWITTER_HANDLE = 'CoachChuckFF';\nconst TWITTER_LINK = `https://twitter.com/${TWITTER_HANDLE}`;\n\nconst App = () => {\n  // State\n  const [creditsLeft, setCreditsLeft] = useState(0);\n  const [walletAddress, setWalletAddress] = useState(null);\n  const [mekAddress, setMekAddress] = useState(null);\n  const [pfpAddress, setPfpAddress] = useState(null);\n  const [pfpScale, setPfpScale] = useState(0.15);\n  const [isBuilding, setIsBuilding] = useState(false);\n  const [didDownload, setDidDownload] = useState(false);\n  const [isGettingNFTS, setIsGettingNFTs] = useState(false);\n  const [nftList, setNftList] = useState([]);\n\n  const getURLData = (baseURL = '', path = '', params = {}) => {\n    let requestedURL = baseURL + path + ((params.length == 0) ? \"\" : \"?\" + querystring.stringify(params));\n    return new Promise((resolve, reject) => {\n      fetch(requestedURL, {\n        method: 'GET',\n        cache: 'no-cache',\n        headers: {'accept': 'application/json'},\n        redirect: 'follow',\n        referrerPolicy: 'no-referrer',\n      }).then((response) => {\n        response.json().then((data)=>{\n          resolve(data);\n        })\n        .catch((error) => {reject(`Could not get JSON (${requestedURL})`);});\n      })\n      .catch((error) => {reject(`Could not get URL (${requestedURL})`);});\n    });\n  }\n\n  const grabAllNFTs = () => {\n    if(!isGettingNFTS){\n      setIsGettingNFTs(true);\n      getURLData(\n        \"https://public-api.solscan.io\",\n        \"/account/tokens\",\n        { account: `${walletAddress}`,},\n      ).then((data) => {\n\n        //Grab NFT Tokens\n        let promises = [];\n        data.forEach(token => {\n          if(token.tokenAmount != null && token.tokenAmount.amount == 1 && token.tokenAmount.decimals == 0){\n            promises.push(\n              getURLData(\n                \"https://public-api.solscan.io\",\n                `/account/${token.tokenAddress}`,\n              )\n            );\n          }\n        });\n\n        // Get Metadata on all\n        Promise.all(promises)\n        .then((nfts)=>{\n          \n          //Grab only the useful stuff\n          let nftMetadata = [];\n          nfts.forEach(nft=> {\n            try{\n              if(nft.metadata == null){throw new Error('No metadata');}\n              if(nft.metadata.data.name == null){throw new Error('No name!');}\n              if(nft.metadata.data.collection == null && nft.tokenInfo.symbol == null){throw new Error(nft.metadata.data.name + \" Bad collection\");}\n              if(nft.metadata.data.image == null){throw new Error(nft.metadata.data.name + \" Bad image\");}\n              if(nft.account == null){throw new Error(nft.metadata.data.name + \" Bad account\");}\n\n              //Fuck Collections\n              let collection = null;\n              if(nft.metadata.data.collection != null){\n                if(typeof nft.metadata.data.collection === 'string'){\n                  collection = nft.metadata.data.collection;\n                } else {\n                  collection = nft.metadata.data.collection.name;\n                }\n              }\n              if(collection == null) collection = nft.tokenInfo.symbol;\n              if(collection == null) throw new Error(nft.metadata.data.name + \" Bad collection... Again\");\n\n              nftMetadata.push(\n                {\n                  name : nft.metadata.data.name, \n                  collection : collection,\n                  url : nft.metadata.data.image,\n                  address : nft.account,\n                }\n              );\n            } catch (error){\n              console.log(error);\n            }\n          });\n\n          //Sort\n          nftMetadata.sort((a, b)=>{\n            return a.collection.localeCompare(b.collection);\n          });\n\n          //Update\n          setNftList(nftMetadata);\n          setIsGettingNFTs(false);\n        })\n        .catch((error) => {\n          alert('Could not grab ALL NFTs');\n          console.log(error);\n          setIsGettingNFTs(false);\n        })\n\n      })\n      .catch((error) => {\n        alert('Could not grab NFTs');\n        console.log(error);\n        setIsGettingNFTs(false);\n      })\n    } else {\n      console.log(\"Crawling...\")\n    }\n  }\n\n  const getCreditsLeft = async () => {\n    try {\n      const response = await fetch(`/server/credits`);\n      const data = await response.json();\n      setCreditsLeft(data.credits);\n    } catch {\n      console.log(\"Could not grab credits\");\n    }\n  }\n\n  const clearIMG = async () => {\n    try {\n      const response = await fetch(`/server/clear/${walletAddress}`);\n      const data = await response.json();\n      console.log(data);\n    } catch {\n      console.log(\"Could not grab credits\");\n    }\n  }\n\n  const downloadNewMek = async () => {\n    if(didDownload){\n      alert('You just downloaded!');\n    } else if(mekAddress == null || pfpAddress == null){\n      alert('Need to pick both a Mekamount and PFP');\n    } else if(!isBuilding){\n      setIsBuilding(true);\n      try {\n        const response = await fetch(`/server/sol/${walletAddress}/meka/${mekAddress.address}/pfp/${pfpAddress.address}/scale/${pfpScale}`);\n        const blob = await response.blob();\n\n        if(blob.size < 500){\n          const data = await response.json();\n          if(data.error != null){\n            alert(data.error);\n          } else {\n            alert('Error merging NFTs');\n          }\n        } else {\n          download(blob, \"mekamount.png\");\n          setDidDownload(true);\n          getCreditsLeft();\n          clearIMG();\n        }\n\n      } catch (error) {\n        alert('Error merging NFTs');\n      }\n\n      setIsBuilding(false);\n    } else {\n      alert('Building...');\n    }\n  };\n\n  const scrollToTop = () => {\n    window.scrollTo({\n      top: 0,\n      behavior: 'smooth' // for smoothly scrolling\n    });\n  };\n\n  const selectNFT = (nft) => {\n\n    if(nft.name.includes(\"Mekamounts\")){\n      setMekAddress(nft);\n    } else {\n      setPfpAddress(nft);\n    }\n    \n    // scrollToTop();\n  }\n\n  const renderConnectedContainer = () => (\n    <div className=\"connected-container\">\n        <div className=\"selected-grid\">\n        {<div className=\"selected-item\" key={\"meka\"}>\n          <img src={mekAddress == null ? mekaHolder : mekAddress.url} alt={mekaHolder} />\n          <p className=\"sub-text\">{mekAddress == null ? \"\" : \"Mekamount\"}</p>\n        </div>}\n        {<div className=\"selected-item\" key={\"pfp\"}>\n          <img src={pfpAddress == null ? pfpHolder : pfpAddress.url} alt={pfpHolder} />\n          <p className=\"sub-text\">{pfpAddress == null ? \"\" : \"PFP\"}</p>\n        </div>}\n      </div>\n      <div className='mini-spacing'></div>\n      <button type=\"submit\" className=\"cta-button submit-gif-button\" onClick={downloadNewMek} disabled={isBuilding}>\n        {didDownload ? \"Complete!\" : (isBuilding ? \"Building...\" : \"Build\")}\n      </button>\n      <div className='spacing'></div>\n      <p className=\"sub-text\">Choose your Mekamount...</p>\n      <div className=\"gif-grid\">\n        {/* Map through gifList instead of TEST_GIFS */}\n        {nftList.filter((nft) => { return nft.name.includes(\"Mekamounts\");}).map((nft) => (\n          <div className=\"gif-item\" key={nft.url} onClick={() => {selectNFT(nft)}}>\n            <img src={nft.url} alt={nft.url} />\n            <p className=\"sub-text\">{nft.name}</p>\n            <div className='mini-spacing'></div>\n          </div>\n        ))}\n      </div>\n      <p className=\"sub-text\">Choose your PFP...</p>\n      <div className=\"gif-grid\">\n        {/* Map through gifList instead of TEST_GIFS */}\n        {nftList.filter((nft) => { return !nft.name.includes(\"Mekamounts\");}).map((nft) => (\n          <div className=\"gif-item\" key={nft.url} onClick={() => {selectNFT(nft)}}>\n            <img src={nft.url} alt={nft.url} />\n            <p className=\"sub-text\">{nft.name}</p>\n            <div className='mini-spacing'></div>\n          </div>\n        ))}\n      </div>\n      <div className='spacing'></div>\n    </div>\n  );\n\n  // Actions\n  const checkIfWalletIsConnected = async () => {\n    try {\n      const { solana } = window;\n\n      if (solana) {\n        if (solana.isPhantom) {\n          console.log('Phantom wallet found!');\n          const response = await solana.connect({ onlyIfTrusted: true });\n          console.log(\n            'Connected with Public Key:',\n            response.publicKey.toString()\n          );\n\n          setWalletAddress(response.publicKey.toString());\n        }\n      } else {\n        alert('Solana object not found! Get a Phantom Wallet 👻');\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  const connectWallet = async () => {\n    const { solana } = window;\n  \n    if (solana) {\n      const response = await solana.connect();\n      console.log('Connected with Public Key:', response.publicKey.toString());\n      setWalletAddress(response.publicKey.toString());\n    }\n  };\n\n  // const onInputChange = (event) => {\n  //   const { value } = event.target;\n  //   setInputValue(value);\n  // };\n  \n  const sendGif = async () => {\n    // if (inputValue.length > 0) {\n    //   console.log('Gif link:', inputValue);\n    //   setGifList([...gifList, inputValue]);\n    //   setInputValue('');\n    // } else {\n    //   console.log('Empty input. Try again.');\n    // }\n  };\n\n  const renderNotConnectedContainer = () => (\n    <button\n      className=\"cta-button connect-wallet-button\"\n      onClick={connectWallet}\n    >\n      Connect to Wallet\n    </button>\n  );\n\n  // UseEffects\n  useEffect(() => {\n    const onLoad = async () => {\n      await checkIfWalletIsConnected();\n      await getCreditsLeft();\n    };\n    window.addEventListener('load', onLoad);\n    return () => window.removeEventListener('load', onLoad);\n  }, []);\n  \n  useEffect(() => {\n    if (walletAddress) {\n      console.log('Fetching Mekamounts...');\n      \n      // Call Solana program here.\n      grabAllNFTs();\n  \n      // Set state\n      // setGifList(TEST_GIFS);\n    }\n  }, [walletAddress]);\n\n  return (\n    <div className=\"App\">\n\t\t\t{/* This was solely added for some styling fanciness */}\n\t\t\t<div className={walletAddress ? 'authed-container' : 'container'}>\n        <div className=\"header-container\">\n          <p className=\"header\">🦾 Mekamount PFP Portal [CR Left: {creditsLeft}]</p>\n          <p className=\"sub-text\">\n            N F T ✨\n          </p>\n          {!walletAddress && renderNotConnectedContainer()}\n          {/* We just need to add the inverse here! */}\n          {walletAddress && renderConnectedContainer()}\n        </div>\n        <div className='spacing'></div>\n        <div className=\"footer-container\">\n          <img alt=\"Twitter Logo\" className=\"twitter-logo\" src={twitterLogo} />\n          <a\n            className=\"footer-text\"\n            href={TWITTER_LINK}\n            target=\"_blank\"\n            rel=\"noreferrer\"\n          >{`Crafted By @${TWITTER_HANDLE}`}</a>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default App;",{"ruleId":"21","replacedBy":"22"},{"ruleId":"23","replacedBy":"24"},{"ruleId":"25","severity":1,"message":"26","line":20,"column":20,"nodeType":"27","messageId":"28","endLine":20,"endColumn":31},{"ruleId":"29","severity":1,"message":"30","line":27,"column":57,"nodeType":"31","messageId":"32","endLine":27,"endColumn":59},{"ruleId":"29","severity":1,"message":"30","line":57,"column":68,"nodeType":"31","messageId":"32","endLine":57,"endColumn":70},{"ruleId":"29","severity":1,"message":"30","line":57,"column":103,"nodeType":"31","messageId":"32","endLine":57,"endColumn":105},{"ruleId":"25","severity":1,"message":"33","line":187,"column":9,"nodeType":"27","messageId":"28","endLine":187,"endColumn":20},{"ruleId":"25","severity":1,"message":"34","line":287,"column":9,"nodeType":"27","messageId":"28","endLine":287,"endColumn":16},{"ruleId":"35","severity":1,"message":"36","line":326,"column":6,"nodeType":"37","endLine":326,"endColumn":21,"suggestions":"38"},"no-native-reassign",["39"],"no-negated-in-lhs",["40"],"no-unused-vars","'setPfpScale' is assigned a value but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'scrollToTop' is assigned a value but never used.","'sendGif' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'grabAllNFTs'. Either include it or remove the dependency array.","ArrayExpression",["41"],"no-global-assign","no-unsafe-negation",{"desc":"42","fix":"43"},"Update the dependencies array to be: [grabAllNFTs, walletAddress]",{"range":"44","text":"45"},[10269,10284],"[grabAllNFTs, walletAddress]"]